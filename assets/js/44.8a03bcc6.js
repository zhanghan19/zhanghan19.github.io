(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{463:function(t,a,v){"use strict";v.r(a);var s=v(27),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_15-flex排版"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-flex排版"}},[t._v("#")]),t._v(" 15. Flex排版")]),t._v(" "),v("h2",{attrs:{id:"flex排版"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex排版"}},[t._v("#")]),t._v(" Flex排版")]),t._v(" "),v("ul",[v("li",[t._v("收集"),v("strong",[t._v("盒")]),t._v("进行")]),t._v(" "),v("li",[t._v("计算盒在主轴方向的排布")]),t._v(" "),v("li",[t._v("计算盒在交叉轴方向的排布")])]),t._v(" "),v("h2",{attrs:{id:"分行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分行"}},[t._v("#")]),t._v(" 分行")]),t._v(" "),v("ul",[v("li",[t._v("根据主轴尺寸，把元素分进行")]),t._v(" "),v("li",[t._v("若设置了no-wrap，则强行分配进第一行")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/images/flex1.png",alt:"分行"}})]),t._v(" "),v("h2",{attrs:{id:"计算主轴方向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算主轴方向"}},[t._v("#")]),t._v(" 计算主轴方向")]),t._v(" "),v("ul",[v("li",[t._v("找出所有Flex元素")]),t._v(" "),v("li",[t._v("把主轴方向的剩余尺寸按比例分配给这些元素")]),t._v(" "),v("li",[t._v("若剩余空间为负数，所有flex元素为0，等比压缩剩余元素")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/images/flex2.png",alt:"计算主轴方向"}})]),t._v(" "),v("h2",{attrs:{id:"flex规则解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex规则解析"}},[t._v("#")]),t._v(" Flex规则解析")]),t._v(" "),v("h3",{attrs:{id:"声明定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#声明定义"}},[t._v("#")]),t._v(" 声明定义")]),t._v(" "),v("p",[t._v("容器盒子里面包含着容器元素，使用 display:flex 或 display:inline-flex 声明为弹性盒子。")]),t._v(" "),v("h3",{attrs:{id:"flex-direction"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-direction"}},[t._v("#")]),t._v(" flex-direction")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("用于控制盒子元素排列的方向")]),v("p",[t._v("一个弹性盒子中的每一项的排版方式有两种横排和竖排，那么横排和竖排的顺序又分正序和倒叙，所以弹性盒子中的每一项有四种排版方式")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("row")]),t._v(" "),v("td",[t._v("从左到右水平排列元素（默认值）"),v("font",{attrs:{color:"#ff0000"}},[t._v("主轴就是水平方向")])],1)]),t._v(" "),v("tr",[v("td",[t._v("row-reverse")]),t._v(" "),v("td",[t._v("从右向左排列元素")])]),t._v(" "),v("tr",[v("td",[t._v("column")]),t._v(" "),v("td",[t._v("从上到下垂直排列元素\t\t\t"),v("font",{attrs:{color:"#ff0000"}},[t._v("主轴就是垂直方向")])],1)]),t._v(" "),v("tr",[v("td",[t._v("column-reverse")]),t._v(" "),v("td",[t._v("从下到上垂直排列元素")])])])]),t._v(" "),v("h3",{attrs:{id:"flex-wrap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-wrap"}},[t._v("#")]),t._v(" flex-wrap")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。")]),v("p",[t._v("一个弹性盒子中的每一项是横向排布，如果一行排不下，这时分三种情况： 第一等比缩放（默认）， 第二折行 ，第三 硬刚（超出就超出）")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("nowrap")]),t._v(" "),v("td",[t._v("元素不拆行或不拆列（默认值）")])]),t._v(" "),v("tr",[v("td",[t._v("wrap")]),t._v(" "),v("td",[t._v("容器元素在必要的时候拆行或拆列。")])]),t._v(" "),v("tr",[v("td",[t._v("wrap-reverse")]),t._v(" "),v("td",[t._v("容器元素在必要的时候拆行或拆列，但是以相反的顺序")])])])]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("主轴")]),v("p",[t._v("flex-direction: row;  主轴就是水平方向")]),t._v(" "),v("p",[t._v("flex-direction: column;  主轴就是垂直方向")])]),v("h3",{attrs:{id:"justify-content"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#justify-content"}},[t._v("#")]),t._v(" justify-content")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("主轴的排列方式")]),v("p",[t._v("用于控制元素在主轴上的排列方式，再次强调是主轴的排列方式。")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("flex-start")]),t._v(" "),v("td",[t._v("元素紧靠主轴起点")])]),t._v(" "),v("tr",[v("td",[t._v("flex-end")]),t._v(" "),v("td",[t._v("元素紧靠主轴终点")])]),t._v(" "),v("tr",[v("td",[t._v("center")]),t._v(" "),v("td",[t._v("元素从弹性容器中心开始")])]),t._v(" "),v("tr",[v("td",[t._v("space-between")]),t._v(" "),v("td",[t._v("第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间")])]),t._v(" "),v("tr",[v("td",[t._v("space-around")]),t._v(" "),v("td",[t._v("每个元素两侧的间隔相等。所以，元素之间的间隔比元素与容器的边距的间隔大一倍")])]),t._v(" "),v("tr",[v("td",[t._v("space-evenly")]),t._v(" "),v("td",[t._v("元素间距离平均分配")])])])]),t._v(" "),v("h3",{attrs:{id:"交叉轴行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#交叉轴行"}},[t._v("#")]),t._v(" 交叉轴行")]),t._v(" "),v("p",[t._v("元素在交叉轴上有行的概念，理解这个概念会对理解align-items与align-content有更好的帮助。")]),t._v(" "),v("ul",[v("li",[t._v("align-item是控制元素在行上的排列")]),t._v(" "),v("li",[t._v("align-content是控制行在交差轴上的排列")])]),t._v(" "),v("h3",{attrs:{id:"align-items"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#align-items"}},[t._v("#")]),t._v(" align-items")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("交叉轴的排列方式")]),v("p",[t._v("用于控制容器元素在交叉轴上的排列方式。")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("stretch")]),t._v(" "),v("td",[t._v("元素被拉伸以适应容器（默认值）")])]),t._v(" "),v("tr",[v("td",[t._v("center")]),t._v(" "),v("td",[t._v("元素位于容器的中心")])]),t._v(" "),v("tr",[v("td",[t._v("flex-start")]),t._v(" "),v("td",[t._v("元素位于容器的交叉轴开头")])]),t._v(" "),v("tr",[v("td",[t._v("flex-end")]),t._v(" "),v("td",[t._v("元素位于容器的交叉轴结尾")])])])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),v("p",[t._v("如果设置了 width | height | min-height | min-width | max-width | max-height ，将影响stretch 的结果，因为 stretch 优先级你于宽高设置。")])]),t._v(" "),v("h3",{attrs:{id:"align-content"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#align-content"}},[t._v("#")]),t._v(" align-content")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("多行时交叉轴的排列方式")]),v("p",[t._v("只适用于多行显示的弹性容器，用于控制行（而不是元素）在交叉轴上的排列方式。")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("stretch")]),t._v(" "),v("td",[t._v("将空间平均分配给元素")])]),t._v(" "),v("tr",[v("td",[t._v("flex-start")]),t._v(" "),v("td",[t._v("元素紧靠主轴起点")])]),t._v(" "),v("tr",[v("td",[t._v("flex-end")]),t._v(" "),v("td",[t._v("元素紧靠主轴终点")])]),t._v(" "),v("tr",[v("td",[t._v("center")]),t._v(" "),v("td",[t._v("元素从弹性容器中心开始")])]),t._v(" "),v("tr",[v("td",[t._v("space-between")]),t._v(" "),v("td",[t._v("第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间")])]),t._v(" "),v("tr",[v("td",[t._v("space-around")]),t._v(" "),v("td",[t._v("每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍")])]),t._v(" "),v("tr",[v("td",[t._v("space-evenly")]),t._v(" "),v("td",[t._v("元素间距离平均分配")])])])]),t._v(" "),v("h3",{attrs:{id:"弹性元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#弹性元素"}},[t._v("#")]),t._v(" 弹性元素")]),t._v(" "),v("p",[t._v("放在容器盒子中的元素即为容器元素。")]),t._v(" "),v("ul",[v("li",[t._v("不能使用float与clear规则")]),t._v(" "),v("li",[t._v("弹性元素均为块元素")]),t._v(" "),v("li",[t._v("绝对定位的弹性元素不参与弹性布局")])]),t._v(" "),v("h3",{attrs:{id:"align-self"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#align-self"}},[t._v("#")]),t._v(" align-self")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("单个盒子交叉轴的排列方式")]),v("p",[t._v("用于控制单个元素在交叉轴上的排列方式，align-items 用于控制容器中所有元素的排列，而 align-self 用于控制一个弹性元素的交叉轴排列。")])]),v("table",[v("thead",[v("tr",[v("th",[t._v("选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("stretch")]),t._v(" "),v("td",[t._v("将空间平均分配给元素")])]),t._v(" "),v("tr",[v("td",[t._v("flex-start")]),t._v(" "),v("td",[t._v("元素紧靠主轴起点")])]),t._v(" "),v("tr",[v("td",[t._v("flex-end")]),t._v(" "),v("td",[t._v("元素紧靠主轴终点")])]),t._v(" "),v("tr",[v("td",[t._v("center")]),t._v(" "),v("td",[t._v("元素从弹性容器中心开始")])])])]),t._v(" "),v("h3",{attrs:{id:"flex-grow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-grow"}},[t._v("#")]),t._v(" flex-grow")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("当主轴排列时有剩余的空间，那么此空间的分配方式如下")]),v("p",[t._v("用于将弹性盒子的可用空间，分配给弹性元素。可以使用整数或小数声明。")])]),v("p",[t._v("如果弹性元素设置了宽度，将把（弹性盒子-弹性元素宽度和）后按照 flex-grow 进行分配 。")]),t._v(" "),v("h3",{attrs:{id:"flex-shrink"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-shrink"}},[t._v("#")]),t._v(" flex-shrink")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("当主轴排列时超出主轴的宽度没有剩余的空间时，那么子元素缩小的比例如何计算")]),v("p",[t._v("与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值。")])]),v("p",[t._v("下例在600宽的弹性盒子中放了 1000 宽的弹性元素。并为最后两个元素设置了缩放，最后一个元素的缩放比例为 500 -( ( (1000-600) / (100X1+400x3+500X6) ) x 3 ) X 500 = 220.9，计算公式说明如下：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("缩小比例 = 不足的空间 / (元素 1 宽度 x 缩小比例) + (元素 2 宽度 x 缩小比例) ...\n最终尺寸 = 元素三宽度 - (缩小比例 x  元素 3 的宽度) X 元素宽度\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("h3",{attrs:{id:"flex-basis"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-basis"}},[t._v("#")]),t._v(" flex-basis")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("主轴的基本尺寸")]),v("p",[t._v("flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。")])]),v("p",[t._v("可以是长度单位，也可以是百分比。flex-basis的优先级高于width、height属性。")]),t._v(" "),v("ul",[v("li",[t._v("优先级")])]),t._v(" "),v("p",[t._v("min-width、min-height 优先级大于 flex-basis 优先级大于 width、height。")]),t._v(" "),v("h3",{attrs:{id:"flex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex"}},[t._v("#")]),t._v(" flex")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("缩写")]),v("p",[t._v("flex是flex-grow、flex-shrink 、flex-basis缩写组合。")])]),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v("建议使用 flex 面不要单独使用 flex-grow / flew-shrink / flex-basis 。")])]),t._v(" "),v("h3",{attrs:{id:"order"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#order"}},[t._v("#")]),t._v(" order")]),t._v(" "),v("div",{staticClass:"theorem"},[v("p",{staticClass:"title"},[t._v("改变元素的顺序")]),v("p",[t._v("用于控制弹性元素的位置，默认为 order:0 数值越小越在前面，可以负数或整数。")])]),v("h3",{attrs:{id:"弹性文本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#弹性文本"}},[t._v("#")]),t._v(" 弹性文本")]),t._v(" "),v("p",[t._v("文本节点也在弹性布局操作范围内")]),t._v(" "),v("h3",{attrs:{id:"绝对定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#绝对定位"}},[t._v("#")]),t._v(" 绝对定位")]),t._v(" "),v("p",[t._v("绝对定位的弹性元素不参与弹性布局")]),t._v(" "),v("h3",{attrs:{id:"自动空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动空间"}},[t._v("#")]),t._v(" 自动空间")]),t._v(" "),v("p",[t._v("在弹性布局中对元素使用margin-right:auto 等形式可以自动撑满空间。下例为第一个ul设置 margin-right:auto 表示右侧空间自动撑满，第二个ul靠近父元素右边界。")]),t._v(" "),v("h2",{attrs:{id:"推荐阅读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[t._v("#")]),t._v(" 推荐阅读")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://houdunren.gitee.io/note/css/10%20%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80.html#%E4%BA%86%E8%A7%A3%E5%BC%B9%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("See Also"),v("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);